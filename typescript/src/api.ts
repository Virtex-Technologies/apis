/* tslint:disable */
/* eslint-disable */
/**
 * Virtex API
 * Virtex API
 *
 * The version of the OpenAPI document: v1
 * Contact: info@virtex.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id': number;
    /**
     * 
     * @type {Account}
     * @memberof Account
     */
    'parent'?: Account;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {Entity}
     * @memberof Account
     */
    'entity'?: Entity;
    /**
     * 
     * @type {Entity}
     * @memberof Account
     */
    'counterparty'?: Entity;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'counterpartyAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'venue'?: string;
    /**
     * 
     * @type {Array<Account>}
     * @memberof Account
     */
    'subAccounts'?: Array<Account>;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'broker'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    'entityId': number;
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    'counterpartyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'counterpartyAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'venue'?: string;
}
/**
 * 
 * @export
 * @interface AccountKey
 */
export interface AccountKey {
    /**
     * 
     * @type {number}
     * @memberof AccountKey
     */
    'id'?: number;
    /**
     * 
     * @type {Account}
     * @memberof AccountKey
     */
    'account'?: Account;
    /**
     * 
     * @type {string}
     * @memberof AccountKey
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKey
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface AccountKeyDto
 */
export interface AccountKeyDto {
    /**
     * 
     * @type {number}
     * @memberof AccountKeyDto
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountKeyDto
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDto
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDto
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface AccountMessage
 */
export interface AccountMessage extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof AccountMessage
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountMessage
     */
    'entityId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountMessage
     */
    'counterpartyId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountMessage
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountMessage
     */
    'venue'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountMessage
     */
    'counterpartyAccountId'?: string;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'assetType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Auth0UserDto
 */
export interface Auth0UserDto {
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'nickname'?: string;
    /**
     * 
     * @type {Auth0UserMetadata}
     * @memberof Auth0UserDto
     */
    'user_metadata'?: Auth0UserMetadata;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'given_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0UserDto
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface Auth0UserMetadata
 */
export interface Auth0UserMetadata {
    /**
     * 
     * @type {{ [key: string]: Set<string>; }}
     * @memberof Auth0UserMetadata
     */
    'rolesByEntity'?: { [key: string]: Set<string>; };
}
/**
 * 
 * @export
 * @interface Auth0UserMetadataPatchDto
 */
export interface Auth0UserMetadataPatchDto {
    /**
     * 
     * @type {Auth0UserMetadata}
     * @memberof Auth0UserMetadataPatchDto
     */
    'user_metadata'?: Auth0UserMetadata;
}
/**
 * 
 * @export
 * @interface Auth0UserPage
 */
export interface Auth0UserPage {
    /**
     * 
     * @type {number}
     * @memberof Auth0UserPage
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof Auth0UserPage
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Auth0UserPage
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof Auth0UserPage
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Auth0UserDto>}
     * @memberof Auth0UserPage
     */
    'users'?: Array<Auth0UserDto>;
}
/**
 * 
 * @export
 * @interface Deposit
 */
export interface Deposit {
    /**
     * 
     * @type {number}
     * @memberof Deposit
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof Deposit
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof Deposit
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'emailType'?: EmailEmailTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'clOrdId'?: string;
}

export const EmailEmailTypeEnum = {
    New: 'NEW',
    Admin: 'ADMIN',
    Reply: 'REPLY'
} as const;

export type EmailEmailTypeEnum = typeof EmailEmailTypeEnum[keyof typeof EmailEmailTypeEnum];

/**
 * 
 * @export
 * @interface Ent
 */
export interface Ent {
    /**
     * 
     * @type {number}
     * @memberof Ent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Ent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ent
     */
    'lei'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ent
     */
    'entityType'?: EntEntityTypeEnum;
}

export const EntEntityTypeEnum = {
    Broker: 'BROKER',
    Ecn: 'ECN',
    Bank: 'BANK',
    Principal: 'PRINCIPAL',
    Exchange: 'EXCHANGE',
    Corporate: 'CORPORATE',
    Individual: 'INDIVIDUAL'
} as const;

export type EntEntityTypeEnum = typeof EntEntityTypeEnum[keyof typeof EntEntityTypeEnum];

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'entityType'?: EntityEntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'lei'?: string;
    /**
     * 
     * @type {Entity}
     * @memberof Entity
     */
    'parent'?: Entity;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    'broker'?: boolean;
}

export const EntityEntityTypeEnum = {
    Broker: 'BROKER',
    Ecn: 'ECN',
    Bank: 'BANK',
    Principal: 'PRINCIPAL',
    Exchange: 'EXCHANGE',
    Corporate: 'CORPORATE',
    Individual: 'INDIVIDUAL'
} as const;

export type EntityEntityTypeEnum = typeof EntityEntityTypeEnum[keyof typeof EntityEntityTypeEnum];

/**
 * 
 * @export
 * @interface EntityDto
 */
export interface EntityDto {
    /**
     * 
     * @type {number}
     * @memberof EntityDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EntityDto
     */
    'entityType': EntityDtoEntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityDto
     */
    'lei'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityDto
     */
    'parentId'?: number;
}

export const EntityDtoEntityTypeEnum = {
    Broker: 'BROKER',
    Ecn: 'ECN',
    Bank: 'BANK',
    Principal: 'PRINCIPAL',
    Exchange: 'EXCHANGE',
    Corporate: 'CORPORATE',
    Individual: 'INDIVIDUAL'
} as const;

export type EntityDtoEntityTypeEnum = typeof EntityDtoEntityTypeEnum[keyof typeof EntityDtoEntityTypeEnum];

/**
 * 
 * @export
 * @interface ExecutionReport
 */
export interface ExecutionReport extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'execId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'secondaryExecId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'securityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'securityIdSource'?: ExecutionReportSecurityIdSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'securityExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'currencyCodeSource'?: ExecutionReportCurrencyCodeSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'settlCurrency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'settlCurrencyCodeSource'?: ExecutionReportSettlCurrencyCodeSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'ordStatus'?: ExecutionReportOrdStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'transactTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'orderQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'lastPx'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'lastShares'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'lastCapacity'?: ExecutionReportLastCapacityEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'handlInst'?: ExecutionReportHandlInstEnum;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'commission'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'commType'?: ExecutionReportCommTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'lastMkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'exDestination'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'leavesQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'cumQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'cumNotional'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'avgPx'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'side'?: ExecutionReportSideEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'ordType'?: ExecutionReportOrdTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'secondaryClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'clOrdLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'secondaryOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'origClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'execType'?: ExecutionReportExecTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'lastLiquidityInd'?: ExecutionReportLastLiquidityIndEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionReport
     */
    'ordRejReason'?: ExecutionReportOrdRejReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof ExecutionReport
     */
    'timestamp'?: number;
}

export const ExecutionReportSecurityIdSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    IsoCountryCode: 'ISO_Country_Code',
    Broker: 'BROKER',
    IsoCurrencyCode: 'ISO_Currency_Code',
    ExchangeSymbol: 'EXCHANGE_SYMBOL',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ric: 'RIC'
} as const;

export type ExecutionReportSecurityIdSourceEnum = typeof ExecutionReportSecurityIdSourceEnum[keyof typeof ExecutionReportSecurityIdSourceEnum];
export const ExecutionReportCurrencyCodeSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    Iso: 'ISO',
    Figi: 'FIGI',
    Dti: 'DTI',
    Kaiko: 'KAIKO',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ccdata: 'CCDATA'
} as const;

export type ExecutionReportCurrencyCodeSourceEnum = typeof ExecutionReportCurrencyCodeSourceEnum[keyof typeof ExecutionReportCurrencyCodeSourceEnum];
export const ExecutionReportSettlCurrencyCodeSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    Iso: 'ISO',
    Figi: 'FIGI',
    Dti: 'DTI',
    Kaiko: 'KAIKO',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ccdata: 'CCDATA'
} as const;

export type ExecutionReportSettlCurrencyCodeSourceEnum = typeof ExecutionReportSettlCurrencyCodeSourceEnum[keyof typeof ExecutionReportSettlCurrencyCodeSourceEnum];
export const ExecutionReportOrdStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type ExecutionReportOrdStatusEnum = typeof ExecutionReportOrdStatusEnum[keyof typeof ExecutionReportOrdStatusEnum];
export const ExecutionReportLastCapacityEnum = {
    Agency: 'AGENCY',
    CrossAsAgent: 'CROSS_AS_AGENT',
    Principal: 'PRINCIPAL',
    Unknown: 'UNKNOWN',
    RisklessPrincipal: 'RISKLESS_PRINCIPAL',
    CrossAsPrincipal: 'CROSS_AS_PRINCIPAL'
} as const;

export type ExecutionReportLastCapacityEnum = typeof ExecutionReportLastCapacityEnum[keyof typeof ExecutionReportLastCapacityEnum];
export const ExecutionReportHandlInstEnum = {
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type ExecutionReportHandlInstEnum = typeof ExecutionReportHandlInstEnum[keyof typeof ExecutionReportHandlInstEnum];
export const ExecutionReportCommTypeEnum = {
    Absolute: 'ABSOLUTE',
    Percentage: 'PERCENTAGE',
    PerShare: 'PER_SHARE'
} as const;

export type ExecutionReportCommTypeEnum = typeof ExecutionReportCommTypeEnum[keyof typeof ExecutionReportCommTypeEnum];
export const ExecutionReportSideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type ExecutionReportSideEnum = typeof ExecutionReportSideEnum[keyof typeof ExecutionReportSideEnum];
export const ExecutionReportOrdTypeEnum = {
    Market: 'MARKET',
    Limit: 'LIMIT'
} as const;

export type ExecutionReportOrdTypeEnum = typeof ExecutionReportOrdTypeEnum[keyof typeof ExecutionReportOrdTypeEnum];
export const ExecutionReportExecTypeEnum = {
    New: 'NEW',
    Trade: 'TRADE',
    Expired: 'EXPIRED',
    Restated: 'RESTATED',
    Replaced: 'REPLACED',
    TriggeredOrActivatedBySystem: 'TRIGGERED_OR_ACTIVATED_BY_SYSTEM',
    PendingReplace: 'PENDING_REPLACE',
    Calculated: 'CALCULATED',
    Stopped: 'STOPPED',
    Suspended: 'SUSPENDED',
    Canceled: 'CANCELED',
    TradeHasBeenReleasedToClearing: 'TRADE_HAS_BEEN_RELEASED_TO_CLEARING',
    PendingCancel: 'PENDING_CANCEL',
    TradeCancel: 'TRADE_CANCEL',
    PendingNew: 'PENDING_NEW',
    TradeCorrect: 'TRADE_CORRECT',
    OrderStatus: 'ORDER_STATUS',
    DoneForDay: 'DONE_FOR_DAY',
    TradeInAClearingHold: 'TRADE_IN_A_CLEARING_HOLD',
    Rejected: 'REJECTED'
} as const;

export type ExecutionReportExecTypeEnum = typeof ExecutionReportExecTypeEnum[keyof typeof ExecutionReportExecTypeEnum];
export const ExecutionReportLastLiquidityIndEnum = {
    Added: 'ADDED',
    RoutedOut: 'ROUTED_OUT',
    Removed: 'REMOVED'
} as const;

export type ExecutionReportLastLiquidityIndEnum = typeof ExecutionReportLastLiquidityIndEnum[keyof typeof ExecutionReportLastLiquidityIndEnum];
export const ExecutionReportOrdRejReasonEnum = {
    ExceededMaximumNotionalOrderAmount: 'EXCEEDED_MAXIMUM_NOTIONAL_ORDER_AMOUNT',
    StaleOrder: 'STALE_ORDER',
    IncorrectQuantity: 'INCORRECT_QUANTITY',
    ShortSellNotPermitted: 'SHORT_SELL_NOT_PERMITTED',
    PriceExceedsCurrentPriceBand: 'PRICE_EXCEEDS_CURRENT_PRICE_BAND',
    InvalidOrMissingEntitlements: 'INVALID_OR_MISSING_ENTITLEMENTS',
    ExchangeClosed: 'EXCHANGE_CLOSED',
    ReferencePriceNotAvailable: 'REFERENCE_PRICE_NOT_AVAILABLE',
    OrderExceedsLimit: 'ORDER_EXCEEDS_LIMIT',
    LastLookLatency: 'LAST_LOOK_LATENCY',
    ExceededCs01Limit: 'EXCEEDED_CS01_LIMIT',
    TooLateToEnter: 'TOO_LATE_TO_ENTER',
    UnknownSymbol: 'UNKNOWN_SYMBOL',
    ExceededClipSizeLimit: 'EXCEEDED_CLIP_SIZE_LIMIT',
    NotionalValueExceedsThreshold: 'NOTIONAL_VALUE_EXCEEDS_THRESHOLD',
    ExceededDv01Pv01Limit: 'EXCEEDED_DV01_PV01_LIMIT',
    ShortSellRejectedDueToAccountPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_ACCOUNT_PRE_BORROW_RESTRICTION',
    InsufficientCreditLimit: 'INSUFFICIENT_CREDIT_LIMIT',
    DuplicateOrder: 'DUPLICATE_ORDER',
    DuplicateVerballyCommunicatedOrder: 'DUPLICATE_VERBALLY_COMMUNICATED_ORDER',
    LastLook: 'LAST_LOOK',
    Other: 'OTHER',
    UnknownOrder: 'UNKNOWN_ORDER',
    UnavailablePriceOrLiquidity: 'UNAVAILABLE_PRICE_OR_LIQUIDITY',
    InvalidPriceIncrement: 'INVALID_PRICE_INCREMENT',
    UnknownAccount: 'UNKNOWN_ACCOUNT',
    AlgorithmRiskThresholdBreached: 'ALGORITHM_RISK_THRESHOLD_BREACHED',
    BrokerOption: 'BROKER_OPTION',
    ShortSellRejectedDueToSecurityPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_SECURITY_PRE_BORROW_RESTRICTION'
} as const;

export type ExecutionReportOrdRejReasonEnum = typeof ExecutionReportOrdRejReasonEnum[keyof typeof ExecutionReportOrdRejReasonEnum];

/**
 * 
 * @export
 * @interface FixMessageObject
 */
export interface FixMessageObject {
    /**
     * 
     * @type {number}
     * @memberof FixMessageObject
     */
    'seqNum'?: number;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'senderSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'targetSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'traceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'spanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof FixMessageObject
     */
    'sendingTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof FixMessageObject
     */
    'msgType'?: string;
}
/**
 * @type GetMessages200ResponseInner
 * @export
 */
export type GetMessages200ResponseInner = AccountMessage | Email | ExecutionReport | Logon | Logout | NewOrderSingle | OrderCancelRequest | PositionReport | Quote | SecurityList | UserRequest | UserResponse;

/**
 * 
 * @export
 * @interface Instrument
 */
export interface Instrument {
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'securityType'?: InstrumentSecurityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'symbol'?: string;
    /**
     * 
     * @type {Venue}
     * @memberof Instrument
     */
    'venue'?: Venue;
    /**
     * 
     * @type {Asset}
     * @memberof Instrument
     */
    'base'?: Asset;
    /**
     * 
     * @type {Asset}
     * @memberof Instrument
     */
    'quote'?: Asset;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Instrument
     */
    'securityIds'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'tickIncrement'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'lowLimitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'highLimitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'roundLot'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'minTradeVol'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instrument
     */
    'maxTradeVol'?: number;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'securityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'securityExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'securityIdSource'?: InstrumentSecurityIdSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof Instrument
     */
    'venueSymbol'?: string;
}

export const InstrumentSecurityTypeEnum = {
    Opt: 'OPT',
    Fut: 'FUT',
    Perp: 'PERP',
    Digital: 'DIGITAL'
} as const;

export type InstrumentSecurityTypeEnum = typeof InstrumentSecurityTypeEnum[keyof typeof InstrumentSecurityTypeEnum];
export const InstrumentSecurityIdSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    IsoCountryCode: 'ISO_Country_Code',
    Broker: 'BROKER',
    IsoCurrencyCode: 'ISO_Currency_Code',
    ExchangeSymbol: 'EXCHANGE_SYMBOL',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ric: 'RIC'
} as const;

export type InstrumentSecurityIdSourceEnum = typeof InstrumentSecurityIdSourceEnum[keyof typeof InstrumentSecurityIdSourceEnum];

/**
 * 
 * @export
 * @interface Logon
 */
export interface Logon extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof Logon
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logon
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logon
     */
    'encryptedPassword'?: string;
}
/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface NewOrderSingle
 */
export interface NewOrderSingle extends FixMessageObject {
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'transactTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'securityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'securityIdSource'?: NewOrderSingleSecurityIdSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'securityExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'currencyCodeSource'?: NewOrderSingleCurrencyCodeSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'settlCurrency'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'settlCurrencyCodeSource'?: NewOrderSingleSettlCurrencyCodeSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'exDestination'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'origClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'secondaryClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'clOrdLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'orderLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'complianceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'refOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'quoteId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'side': NewOrderSingleSideEnum;
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'orderQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'ordType'?: NewOrderSingleOrdTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'handlInst'?: NewOrderSingleHandlInstEnum;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'timeInForce'?: NewOrderSingleTimeInForceEnum;
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'orderCapacity'?: NewOrderSingleOrderCapacityEnum;
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'displayQty'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'pegPriceType'?: NewOrderSinglePegPriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NewOrderSingle
     */
    'participationRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'targetStrategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrderSingle
     */
    'targetStrategyParameters'?: string;
}

export const NewOrderSingleSecurityIdSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    IsoCountryCode: 'ISO_Country_Code',
    Broker: 'BROKER',
    IsoCurrencyCode: 'ISO_Currency_Code',
    ExchangeSymbol: 'EXCHANGE_SYMBOL',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ric: 'RIC'
} as const;

export type NewOrderSingleSecurityIdSourceEnum = typeof NewOrderSingleSecurityIdSourceEnum[keyof typeof NewOrderSingleSecurityIdSourceEnum];
export const NewOrderSingleCurrencyCodeSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    Iso: 'ISO',
    Figi: 'FIGI',
    Dti: 'DTI',
    Kaiko: 'KAIKO',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ccdata: 'CCDATA'
} as const;

export type NewOrderSingleCurrencyCodeSourceEnum = typeof NewOrderSingleCurrencyCodeSourceEnum[keyof typeof NewOrderSingleCurrencyCodeSourceEnum];
export const NewOrderSingleSettlCurrencyCodeSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    Iso: 'ISO',
    Figi: 'FIGI',
    Dti: 'DTI',
    Kaiko: 'KAIKO',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ccdata: 'CCDATA'
} as const;

export type NewOrderSingleSettlCurrencyCodeSourceEnum = typeof NewOrderSingleSettlCurrencyCodeSourceEnum[keyof typeof NewOrderSingleSettlCurrencyCodeSourceEnum];
export const NewOrderSingleSideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type NewOrderSingleSideEnum = typeof NewOrderSingleSideEnum[keyof typeof NewOrderSingleSideEnum];
export const NewOrderSingleOrdTypeEnum = {
    Market: 'MARKET',
    Limit: 'LIMIT'
} as const;

export type NewOrderSingleOrdTypeEnum = typeof NewOrderSingleOrdTypeEnum[keyof typeof NewOrderSingleOrdTypeEnum];
export const NewOrderSingleHandlInstEnum = {
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type NewOrderSingleHandlInstEnum = typeof NewOrderSingleHandlInstEnum[keyof typeof NewOrderSingleHandlInstEnum];
export const NewOrderSingleTimeInForceEnum = {
    Fok: 'FOK',
    Gtd: 'GTD',
    Gtc: 'GTC',
    Ioc: 'IOC',
    Day: 'DAY'
} as const;

export type NewOrderSingleTimeInForceEnum = typeof NewOrderSingleTimeInForceEnum[keyof typeof NewOrderSingleTimeInForceEnum];
export const NewOrderSingleOrderCapacityEnum = {
    Agency: 'AGENCY',
    Principal: 'PRINCIPAL',
    RisklessPrincipal: 'RISKLESS_PRINCIPAL'
} as const;

export type NewOrderSingleOrderCapacityEnum = typeof NewOrderSingleOrderCapacityEnum[keyof typeof NewOrderSingleOrderCapacityEnum];
export const NewOrderSinglePegPriceTypeEnum = {
    OpeningPeg: 'OPENING_PEG',
    TrailingStopPeg: 'TRAILING_STOP_PEG',
    PrimaryPeg: 'PRIMARY_PEG',
    LastPeg: 'LAST_PEG',
    PegToLimitPrice: 'PEG_TO_LIMIT_PRICE',
    MarketPeg: 'MARKET_PEG',
    None: 'NONE',
    PegToVwap: 'PEG_TO_VWAP',
    MidPricePeg: 'MID_PRICE_PEG',
    FixedPegToLocalBestBidOrOfferAtTimeOfOrder: 'FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER'
} as const;

export type NewOrderSinglePegPriceTypeEnum = typeof NewOrderSinglePegPriceTypeEnum[keyof typeof NewOrderSinglePegPriceTypeEnum];

/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'sendingTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'transactTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'senderSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'targetSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'quoteId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'unsolicited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'secondaryClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'secondaryOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'clOrdLinkId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'account'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'securityId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'exDestination'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'handlInst'?: OrderHandlInstEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'timeInForce'?: OrderTimeInForceEnum;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'orderQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'side'?: OrderSideEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'ordType'?: OrderOrdTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'ordStatus'?: OrderOrdStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'ordRejReason'?: OrderOrdRejReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'lastPx'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'lastShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'leavesQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'cumQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'cumNotional'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'avgPx'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'lastMkt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'displayQty'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'pegPriceType'?: OrderPegPriceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'targetStrategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'targetStrategyParameters'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'participationRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'rejectCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'lastUpdateExecId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'downstreamStatus'?: OrderDownstreamStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'terminal'?: boolean;
    /**
     * 
     * @type {Instrument}
     * @memberof Order
     */
    'instrument'?: Instrument;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'pending'?: boolean;
    /**
     * 
     * @type {Account}
     * @memberof Order
     */
    'mappedAccount'?: Account;
    /**
     * 
     * @type {User}
     * @memberof Order
     */
    'originator'?: User;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'previousOrdStatus'?: OrderPreviousOrdStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'lockedPosition'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'unfilledQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'availableQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'pruce'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'openQty'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'symbol'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'external'?: boolean;
}

export const OrderHandlInstEnum = {
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type OrderHandlInstEnum = typeof OrderHandlInstEnum[keyof typeof OrderHandlInstEnum];
export const OrderTimeInForceEnum = {
    Fok: 'FOK',
    Gtd: 'GTD',
    Gtc: 'GTC',
    Ioc: 'IOC',
    Day: 'DAY'
} as const;

export type OrderTimeInForceEnum = typeof OrderTimeInForceEnum[keyof typeof OrderTimeInForceEnum];
export const OrderSideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type OrderSideEnum = typeof OrderSideEnum[keyof typeof OrderSideEnum];
export const OrderOrdTypeEnum = {
    Market: 'MARKET',
    Limit: 'LIMIT'
} as const;

export type OrderOrdTypeEnum = typeof OrderOrdTypeEnum[keyof typeof OrderOrdTypeEnum];
export const OrderOrdStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderOrdStatusEnum = typeof OrderOrdStatusEnum[keyof typeof OrderOrdStatusEnum];
export const OrderOrdRejReasonEnum = {
    ExceededMaximumNotionalOrderAmount: 'EXCEEDED_MAXIMUM_NOTIONAL_ORDER_AMOUNT',
    StaleOrder: 'STALE_ORDER',
    IncorrectQuantity: 'INCORRECT_QUANTITY',
    ShortSellNotPermitted: 'SHORT_SELL_NOT_PERMITTED',
    PriceExceedsCurrentPriceBand: 'PRICE_EXCEEDS_CURRENT_PRICE_BAND',
    InvalidOrMissingEntitlements: 'INVALID_OR_MISSING_ENTITLEMENTS',
    ExchangeClosed: 'EXCHANGE_CLOSED',
    ReferencePriceNotAvailable: 'REFERENCE_PRICE_NOT_AVAILABLE',
    OrderExceedsLimit: 'ORDER_EXCEEDS_LIMIT',
    LastLookLatency: 'LAST_LOOK_LATENCY',
    ExceededCs01Limit: 'EXCEEDED_CS01_LIMIT',
    TooLateToEnter: 'TOO_LATE_TO_ENTER',
    UnknownSymbol: 'UNKNOWN_SYMBOL',
    ExceededClipSizeLimit: 'EXCEEDED_CLIP_SIZE_LIMIT',
    NotionalValueExceedsThreshold: 'NOTIONAL_VALUE_EXCEEDS_THRESHOLD',
    ExceededDv01Pv01Limit: 'EXCEEDED_DV01_PV01_LIMIT',
    ShortSellRejectedDueToAccountPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_ACCOUNT_PRE_BORROW_RESTRICTION',
    InsufficientCreditLimit: 'INSUFFICIENT_CREDIT_LIMIT',
    DuplicateOrder: 'DUPLICATE_ORDER',
    DuplicateVerballyCommunicatedOrder: 'DUPLICATE_VERBALLY_COMMUNICATED_ORDER',
    LastLook: 'LAST_LOOK',
    Other: 'OTHER',
    UnknownOrder: 'UNKNOWN_ORDER',
    UnavailablePriceOrLiquidity: 'UNAVAILABLE_PRICE_OR_LIQUIDITY',
    InvalidPriceIncrement: 'INVALID_PRICE_INCREMENT',
    UnknownAccount: 'UNKNOWN_ACCOUNT',
    AlgorithmRiskThresholdBreached: 'ALGORITHM_RISK_THRESHOLD_BREACHED',
    BrokerOption: 'BROKER_OPTION',
    ShortSellRejectedDueToSecurityPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_SECURITY_PRE_BORROW_RESTRICTION'
} as const;

export type OrderOrdRejReasonEnum = typeof OrderOrdRejReasonEnum[keyof typeof OrderOrdRejReasonEnum];
export const OrderPegPriceTypeEnum = {
    OpeningPeg: 'OPENING_PEG',
    TrailingStopPeg: 'TRAILING_STOP_PEG',
    PrimaryPeg: 'PRIMARY_PEG',
    LastPeg: 'LAST_PEG',
    PegToLimitPrice: 'PEG_TO_LIMIT_PRICE',
    MarketPeg: 'MARKET_PEG',
    None: 'NONE',
    PegToVwap: 'PEG_TO_VWAP',
    MidPricePeg: 'MID_PRICE_PEG',
    FixedPegToLocalBestBidOrOfferAtTimeOfOrder: 'FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER'
} as const;

export type OrderPegPriceTypeEnum = typeof OrderPegPriceTypeEnum[keyof typeof OrderPegPriceTypeEnum];
export const OrderDownstreamStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderDownstreamStatusEnum = typeof OrderDownstreamStatusEnum[keyof typeof OrderDownstreamStatusEnum];
export const OrderPreviousOrdStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderPreviousOrdStatusEnum = typeof OrderPreviousOrdStatusEnum[keyof typeof OrderPreviousOrdStatusEnum];

/**
 * 
 * @export
 * @interface OrderCancelRequest
 */
export interface OrderCancelRequest extends FixMessageObject {
    /**
     * 
     * @type {number}
     * @memberof OrderCancelRequest
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'exDestination'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'side'?: OrderCancelRequestSideEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'origClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCancelRequest
     */
    'orderId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderCancelRequest
     */
    'forced'?: boolean;
    /**
     * 
     * @type {OrderCancelRequest}
     * @memberof OrderCancelRequest
     */
    'instrument'?: OrderCancelRequest;
}

export const OrderCancelRequestSideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type OrderCancelRequestSideEnum = typeof OrderCancelRequestSideEnum[keyof typeof OrderCancelRequestSideEnum];

/**
 * 
 * @export
 * @interface OrderDto
 */
export interface OrderDto {
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'sendingTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'transactTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'senderSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'targetSubId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'quoteId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'unsolicited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'secondaryClOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'secondaryOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'clOrdLinkId'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'account'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'securityId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'exDestination'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'handlInst'?: OrderDtoHandlInstEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'timeInForce'?: OrderDtoTimeInForceEnum;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'orderQty': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'side': OrderDtoSideEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'ordType'?: OrderDtoOrdTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'ordStatus'?: OrderDtoOrdStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'ordRejReason'?: OrderDtoOrdRejReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'lastPx'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'lastShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'leavesQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'cumQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'cumNotional'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'avgPx'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'lastMkt'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'displayQty'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'pegPriceType'?: OrderDtoPegPriceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'targetStrategy'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'targetStrategyParameters'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'participationRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'rejectCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'lastUpdateExecId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'downstreamStatus'?: OrderDtoDownstreamStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'symbol': string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'terminal'?: boolean;
    /**
     * 
     * @type {Instrument}
     * @memberof OrderDto
     */
    'instrument'?: Instrument;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'pending'?: boolean;
    /**
     * 
     * @type {Account}
     * @memberof OrderDto
     */
    'mappedAccount'?: Account;
    /**
     * 
     * @type {User}
     * @memberof OrderDto
     */
    'originator'?: User;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'previousOrdStatus'?: OrderDtoPreviousOrdStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'lockedPosition'?: boolean;
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderDto
     */
    'openChildren'?: Array<Order>;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'unfilledQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'availableQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'pruce'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'openQty'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDto
     */
    'external'?: boolean;
}

export const OrderDtoHandlInstEnum = {
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type OrderDtoHandlInstEnum = typeof OrderDtoHandlInstEnum[keyof typeof OrderDtoHandlInstEnum];
export const OrderDtoTimeInForceEnum = {
    Fok: 'FOK',
    Gtd: 'GTD',
    Gtc: 'GTC',
    Ioc: 'IOC',
    Day: 'DAY'
} as const;

export type OrderDtoTimeInForceEnum = typeof OrderDtoTimeInForceEnum[keyof typeof OrderDtoTimeInForceEnum];
export const OrderDtoSideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type OrderDtoSideEnum = typeof OrderDtoSideEnum[keyof typeof OrderDtoSideEnum];
export const OrderDtoOrdTypeEnum = {
    Market: 'MARKET',
    Limit: 'LIMIT'
} as const;

export type OrderDtoOrdTypeEnum = typeof OrderDtoOrdTypeEnum[keyof typeof OrderDtoOrdTypeEnum];
export const OrderDtoOrdStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderDtoOrdStatusEnum = typeof OrderDtoOrdStatusEnum[keyof typeof OrderDtoOrdStatusEnum];
export const OrderDtoOrdRejReasonEnum = {
    ExceededMaximumNotionalOrderAmount: 'EXCEEDED_MAXIMUM_NOTIONAL_ORDER_AMOUNT',
    StaleOrder: 'STALE_ORDER',
    IncorrectQuantity: 'INCORRECT_QUANTITY',
    ShortSellNotPermitted: 'SHORT_SELL_NOT_PERMITTED',
    PriceExceedsCurrentPriceBand: 'PRICE_EXCEEDS_CURRENT_PRICE_BAND',
    InvalidOrMissingEntitlements: 'INVALID_OR_MISSING_ENTITLEMENTS',
    ExchangeClosed: 'EXCHANGE_CLOSED',
    ReferencePriceNotAvailable: 'REFERENCE_PRICE_NOT_AVAILABLE',
    OrderExceedsLimit: 'ORDER_EXCEEDS_LIMIT',
    LastLookLatency: 'LAST_LOOK_LATENCY',
    ExceededCs01Limit: 'EXCEEDED_CS01_LIMIT',
    TooLateToEnter: 'TOO_LATE_TO_ENTER',
    UnknownSymbol: 'UNKNOWN_SYMBOL',
    ExceededClipSizeLimit: 'EXCEEDED_CLIP_SIZE_LIMIT',
    NotionalValueExceedsThreshold: 'NOTIONAL_VALUE_EXCEEDS_THRESHOLD',
    ExceededDv01Pv01Limit: 'EXCEEDED_DV01_PV01_LIMIT',
    ShortSellRejectedDueToAccountPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_ACCOUNT_PRE_BORROW_RESTRICTION',
    InsufficientCreditLimit: 'INSUFFICIENT_CREDIT_LIMIT',
    DuplicateOrder: 'DUPLICATE_ORDER',
    DuplicateVerballyCommunicatedOrder: 'DUPLICATE_VERBALLY_COMMUNICATED_ORDER',
    LastLook: 'LAST_LOOK',
    Other: 'OTHER',
    UnknownOrder: 'UNKNOWN_ORDER',
    UnavailablePriceOrLiquidity: 'UNAVAILABLE_PRICE_OR_LIQUIDITY',
    InvalidPriceIncrement: 'INVALID_PRICE_INCREMENT',
    UnknownAccount: 'UNKNOWN_ACCOUNT',
    AlgorithmRiskThresholdBreached: 'ALGORITHM_RISK_THRESHOLD_BREACHED',
    BrokerOption: 'BROKER_OPTION',
    ShortSellRejectedDueToSecurityPreBorrowRestriction: 'SHORT_SELL_REJECTED_DUE_TO_SECURITY_PRE_BORROW_RESTRICTION'
} as const;

export type OrderDtoOrdRejReasonEnum = typeof OrderDtoOrdRejReasonEnum[keyof typeof OrderDtoOrdRejReasonEnum];
export const OrderDtoPegPriceTypeEnum = {
    OpeningPeg: 'OPENING_PEG',
    TrailingStopPeg: 'TRAILING_STOP_PEG',
    PrimaryPeg: 'PRIMARY_PEG',
    LastPeg: 'LAST_PEG',
    PegToLimitPrice: 'PEG_TO_LIMIT_PRICE',
    MarketPeg: 'MARKET_PEG',
    None: 'NONE',
    PegToVwap: 'PEG_TO_VWAP',
    MidPricePeg: 'MID_PRICE_PEG',
    FixedPegToLocalBestBidOrOfferAtTimeOfOrder: 'FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER'
} as const;

export type OrderDtoPegPriceTypeEnum = typeof OrderDtoPegPriceTypeEnum[keyof typeof OrderDtoPegPriceTypeEnum];
export const OrderDtoDownstreamStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderDtoDownstreamStatusEnum = typeof OrderDtoDownstreamStatusEnum[keyof typeof OrderDtoDownstreamStatusEnum];
export const OrderDtoPreviousOrdStatusEnum = {
    New: 'NEW',
    PartiallyFilled: 'PARTIALLY_FILLED',
    Calculated: 'CALCULATED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED',
    Filled: 'FILLED',
    PendingCancel: 'PENDING_CANCEL',
    PendingNew: 'PENDING_NEW',
    Unknown: 'UNKNOWN',
    Unsent: 'UNSENT',
    DoneForDay: 'DONE_FOR_DAY',
    Rejected: 'REJECTED'
} as const;

export type OrderDtoPreviousOrdStatusEnum = typeof OrderDtoPreviousOrdStatusEnum[keyof typeof OrderDtoPreviousOrdStatusEnum];

/**
 * 
 * @export
 * @interface OrderQuery
 */
export interface OrderQuery {
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'clOrdId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'clOrdLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderQuery
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'baseAsset'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'quoteAsset'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuery
     */
    'side'?: OrderQuerySideEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrderQuery
     */
    'open'?: boolean;
}

export const OrderQuerySideEnum = {
    Na: 'NA',
    Sell: 'SELL',
    Buy: 'BUY'
} as const;

export type OrderQuerySideEnum = typeof OrderQuerySideEnum[keyof typeof OrderQuerySideEnum];

/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'free'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'locked'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PositionDto
 */
export interface PositionDto {
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'account': number;
    /**
     * 
     * @type {string}
     * @memberof PositionDto
     */
    'asset': string;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'free': number;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'locked': number;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'lastPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PositionDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface PositionReport
 */
export interface PositionReport extends FixMessageObject {
    /**
     * 
     * @type {number}
     * @memberof PositionReport
     */
    'posMaintRptId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionReport
     */
    'venue'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionReport
     */
    'account'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionReport
     */
    'transactTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PositionReport
     */
    'unsolicited'?: boolean;
    /**
     * 
     * @type {Array<Position>}
     * @memberof PositionReport
     */
    'positions'?: Array<Position>;
}
/**
 * 
 * @export
 * @interface ProblemDetail
 */
export interface ProblemDetail {
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetail
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'instance'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProblemDetail
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'quoteId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'quoteReqId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'account'?: number;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'securityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'securityIdSource'?: QuoteSecurityIdSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'securityExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'bidPx'?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'offerPx'?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'bidSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'offerSize'?: number;
}

export const QuoteSecurityIdSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    IsoCountryCode: 'ISO_Country_Code',
    Broker: 'BROKER',
    IsoCurrencyCode: 'ISO_Currency_Code',
    ExchangeSymbol: 'EXCHANGE_SYMBOL',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ric: 'RIC'
} as const;

export type QuoteSecurityIdSourceEnum = typeof QuoteSecurityIdSourceEnum[keyof typeof QuoteSecurityIdSourceEnum];

/**
 * 
 * @export
 * @interface SecListGrp
 */
export interface SecListGrp {
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'securityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'securityIdSource'?: SecListGrpSecurityIdSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'securityExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'venueSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecListGrp
     */
    'securityType'?: SecListGrpSecurityTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'tickIncrement'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'lowLimitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'highLimitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'roundLot'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'minTradeVol'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecListGrp
     */
    'maxTradeVol'?: number;
}

export const SecListGrpSecurityIdSourceEnum = {
    Cusip: 'CUSIP',
    Quik: 'QUIK',
    IsoCountryCode: 'ISO_Country_Code',
    Broker: 'BROKER',
    IsoCurrencyCode: 'ISO_Currency_Code',
    ExchangeSymbol: 'EXCHANGE_SYMBOL',
    Sedol: 'SEDOL',
    Isin: 'ISIN',
    Ric: 'RIC'
} as const;

export type SecListGrpSecurityIdSourceEnum = typeof SecListGrpSecurityIdSourceEnum[keyof typeof SecListGrpSecurityIdSourceEnum];
export const SecListGrpSecurityTypeEnum = {
    Opt: 'OPT',
    Fut: 'FUT',
    Perp: 'PERP',
    Digital: 'DIGITAL'
} as const;

export type SecListGrpSecurityTypeEnum = typeof SecListGrpSecurityTypeEnum[keyof typeof SecListGrpSecurityTypeEnum];

/**
 * 
 * @export
 * @interface SecurityList
 */
export interface SecurityList extends FixMessageObject {
    /**
     * 
     * @type {Array<SecListGrp>}
     * @memberof SecurityList
     */
    'secListGrps'?: Array<SecListGrp>;
    /**
     * 
     * @type {number}
     * @memberof SecurityList
     */
    'numRelatedSym'?: number;
}
/**
 * 
 * @export
 * @interface StrategyState
 */
export interface StrategyState {
    /**
     * 
     * @type {string}
     * @memberof StrategyState
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'startTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'endTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'nextInterval'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'tickSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'stepSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'strategyName'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyState
     */
    'status'?: StrategyStateStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'timePercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'targetQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyState
     */
    'behindQty'?: number;
}

export const StrategyStateStatusEnum = {
    Paused: 'PAUSED',
    Running: 'RUNNING',
    Stopped: 'STOPPED'
} as const;

export type StrategyStateStatusEnum = typeof StrategyStateStatusEnum[keyof typeof StrategyStateStatusEnum];

/**
 * 
 * @export
 * @interface TokenDto
 */
export interface TokenDto {
    /**
     * 
     * @type {string}
     * @memberof TokenDto
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'transactTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'type'?: string;
    /**
     * 
     * @type {Asset}
     * @memberof Transaction
     */
    'base'?: Asset;
    /**
     * 
     * @type {Asset}
     * @memberof Transaction
     */
    'quote'?: Asset;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'qty'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'price'?: number;
    /**
     * 
     * @type {Account}
     * @memberof Transaction
     */
    'from'?: Account;
    /**
     * 
     * @type {Account}
     * @memberof Transaction
     */
    'to'?: Account;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'admin'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles'?: Array<UserRolesEnum>;
}

export const UserRolesEnum = {
    Trade: 'TRADE',
    CancelOnly: 'CANCEL_ONLY',
    Admin: 'ADMIN',
    None: 'NONE',
    View: 'VIEW'
} as const;

export type UserRolesEnum = typeof UserRolesEnum[keyof typeof UserRolesEnum];

/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'sub'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'mesage'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserDto
     */
    'accounts'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'userRequestId'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRequest
     */
    'userRequestType'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'userRequestData'?: string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse extends FixMessageObject {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'userRequestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ValidationProblemDetail
 */
export interface ValidationProblemDetail {
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetail
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetail
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof ValidationProblemDetail
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetail
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationProblemDetail
     */
    'instance'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ValidationProblemDetail
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ValidationProblemDetail
     */
    'invalidFields'?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface Venue
 */
export interface Venue {
    /**
     * 
     * @type {number}
     * @memberof Venue
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'displayName'?: string;
    /**
     * 
     * @type {{ [key: string]: Instrument; }}
     * @memberof Venue
     */
    'instruments'?: { [key: string]: Instrument; };
    /**
     * 
     * @type {{ [key: string]: Instrument; }}
     * @memberof Venue
     */
    'venueSymbols'?: { [key: string]: Instrument; };
}

/**
 * VirtexApi - axios parameter creator
 * @export
 */
export const VirtexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a pending Manual order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('acceptOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a fill to an existing order
         * @param {string} orderId 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFill: async (orderId: string, requestBody: { [key: string]: number; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('addFill', 'orderId', orderId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addFill', 'requestBody', requestBody)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {ExecutionReport} executionReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFill1: async (orderId: string, executionReport: ExecutionReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('addFill1', 'orderId', orderId)
            // verify required parameter 'executionReport' is not null or undefined
            assertParamExists('addFill1', 'executionReport', executionReport)
            const localVarPath = `/orders/{orderId}/fills`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executionReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} account 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole: async (userId: string, account: number, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserRole', 'userId', userId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('addUserRole', 'account', account)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('addUserRole', 'role', role)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an existing order by ClOrdId
         * @param {number} accountId 
         * @param {string} clOrdId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelByClOrdId: async (accountId: number, clOrdId: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('cancelByClOrdId', 'accountId', accountId)
            // verify required parameter 'clOrdId' is not null or undefined
            assertParamExists('cancelByClOrdId', 'clOrdId', clOrdId)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (clOrdId !== undefined) {
                localVarQueryParameter['clOrdId'] = clOrdId;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an existing order
         * @param {string} orderId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountDto} accountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountDto: AccountDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountDto' is not null or undefined
            assertParamExists('createAccount', 'accountDto', accountDto)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountKeyDto} accountKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountKey: async (accountId: number, accountKeyDto: AccountKeyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAccountKey', 'accountId', accountId)
            // verify required parameter 'accountKeyDto' is not null or undefined
            assertParamExists('createAccountKey', 'accountKeyDto', accountKeyDto)
            const localVarPath = `/accounts/{accountId}/keys`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDto} entityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (entityDto: EntityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityDto' is not null or undefined
            assertParamExists('createEntity', 'entityDto', entityDto)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Order
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (newOrderSingle: NewOrderSingle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newOrderSingle' is not null or undefined
            assertParamExists('createOrder', 'newOrderSingle', newOrderSingle)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newOrderSingle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PositionDto} positionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionReport: async (positionDto: PositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionDto' is not null or undefined
            assertParamExists('createPositionReport', 'positionDto', positionDto)
            const localVarPath = `/admin/positions/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Quote} quote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote: async (quote: Quote, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quote' is not null or undefined
            assertParamExists('createQuote', 'quote', quote)
            const localVarPath = `/quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountMessage} accountMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubAccount: async (accountId: number, accountMessage: AccountMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createSubAccount', 'accountId', accountId)
            // verify required parameter 'accountMessage' is not null or undefined
            assertParamExists('createSubAccount', 'accountMessage', accountMessage)
            const localVarPath = `/accounts/{accountId}/subaccounts`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountMessage !== undefined) {
                for (const [key, value] of Object.entries(accountMessage)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountKey: async (accountId: number, keyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountKey', 'accountId', accountId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteAccountKey', 'keyId', keyId)
            const localVarPath = `/accounts/{accountId}/keys/{keyId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Deposit} deposit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (deposit: Deposit, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deposit' is not null or undefined
            assertParamExists('deposit', 'deposit', deposit)
            const localVarPath = `/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deposit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCached: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/positions/cached`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllExchanges: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entities/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPositions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all child slices for an existing orer
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findChildren: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('findChildren', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/children`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInstrument: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findInstrument', 'id', id)
            const localVarPath = `/instruments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOpenOrdersByAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('findOpenOrdersByAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/open_orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all visible orders
         * @param {OrderQuery} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrders: async (query: OrderQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('findOrders', 'query', query)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('findOrdersByAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of top level orders, ie. those not sent by an SOR or Algo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findParentOrders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/parent_orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPositionsByAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('findPositionsByAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/positions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStrategy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findStrategy', 'id', id)
            const localVarPath = `/strategies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountKey: async (accountId: number, keyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountKey', 'accountId', accountId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getAccountKey', 'keyId', keyId)
            const localVarPath = `/accounts/{accountId}/keys/{keyId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterparties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/counterparties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (entityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntity', 'entityId', entityId)
            const localVarPath = `/entities/{entityId}`
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFills: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getFills', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/fills`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (orderId: string, target?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getMessages', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of an existing order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionForAccountAndAsset: async (accountId: number, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPositionForAccountAndAsset', 'accountId', accountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getPositionForAccountAndAsset', 'assetId', assetId)
            const localVarPath = `/accounts/{accountId}/positions/{assetId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsForAsset: async (assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getPositionsForAsset', 'assetId', assetId)
            const localVarPath = `/positions/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice: async (asset: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPrice', 'asset', asset)
            const localVarPath = `/price/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenues: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/venues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [venue] Venue
         * @param {string} [base] Base Asset
         * @param {string} [quote] QuoteAsset
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instruments: async (venue?: string, base?: string, quote?: string, symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (quote !== undefined) {
                localVarQueryParameter['quote'] = quote;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountKeys: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountKeys', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/keys`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/all_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllEntities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/all_entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntityAccounts: async (entityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('listEntityAccounts', 'entityId', entityId)
            const localVarPath = `/entities/{entityId}/accounts`
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubAccounts: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listSubAccounts', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/subaccounts`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserRoles', 'userId', userId)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (q?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logon: async (accountId: number, keyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('logon', 'accountId', accountId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('logon', 'keyId', keyId)
            const localVarPath = `/accounts/{accountId}/keys/{keyId}/logon`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newAccountOrder: async (accountId: number, newOrderSingle: NewOrderSingle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('newAccountOrder', 'accountId', accountId)
            // verify required parameter 'newOrderSingle' is not null or undefined
            assertParamExists('newAccountOrder', 'newOrderSingle', newOrderSingle)
            const localVarPath = `/accounts/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newOrderSingle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseStrategy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pauseStrategy', 'id', id)
            const localVarPath = `/strategies/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPositions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/positions/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeStrategy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resumeStrategy', 'id', id)
            const localVarPath = `/strategies/{id}/resume`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Slice an existing order into a new order
         * @param {Order} orderId 
         * @param {number} orderQty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slice: async (orderId: Order, orderQty: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('slice', 'orderId', orderId)
            // verify required parameter 'orderQty' is not null or undefined
            assertParamExists('slice', 'orderQty', orderQty)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderQty !== undefined) {
                localVarQueryParameter['orderQty'] = orderQty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/md`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        time: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            const localVarPath = `/admin/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {Auth0UserMetadataPatchDto} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles: async (userId: string, roles: Auth0UserMetadataPatchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoles', 'userId', userId)
            // verify required parameter 'roles' is not null or undefined
            assertParamExists('updateUserRoles', 'roles', roles)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roles !== undefined) {
                for (const [key, value] of Object.entries(roles)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtexApi - functional programming interface
 * @export
 */
export const VirtexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtexApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a pending Manual order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.acceptOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a fill to an existing order
         * @param {string} orderId 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFill(orderId: string, requestBody: { [key: string]: number; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFill(orderId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.addFill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {ExecutionReport} executionReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFill1(orderId: string, executionReport: ExecutionReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFill1(orderId, executionReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.addFill1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} account 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRole(userId: string, account: number, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRole(userId, account, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.addUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel an existing order by ClOrdId
         * @param {number} accountId 
         * @param {string} clOrdId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelByClOrdId(accountId: number, clOrdId: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelByClOrdId(accountId, clOrdId, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.cancelByClOrdId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel an existing order
         * @param {string} orderId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(orderId, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.cancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountDto} accountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountDto: AccountDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountKeyDto} accountKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountKey(accountId: number, accountKeyDto: AccountKeyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountKey(accountId, accountKeyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createAccountKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EntityDto} entityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(entityDto: EntityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(entityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Order
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(newOrderSingle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PositionDto} positionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPositionReport(positionDto: PositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPositionReport(positionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createPositionReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Quote} quote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuote(quote: Quote, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuote(quote, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountMessage} accountMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubAccount(accountId: number, accountMessage: AccountMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubAccount(accountId, accountMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createSubAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.createToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountKey(accountId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.deleteAccountKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Deposit} deposit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(deposit: Deposit, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(deposit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.deposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCached(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCached(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findAllCached']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllExchanges(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllExchanges(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findAllExchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPositions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPositions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findAllPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all child slices for an existing orer
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findChildren(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findChildren(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInstrument(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instrument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInstrument(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findInstrument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOpenOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOpenOrdersByAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findOpenOrdersByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all visible orders
         * @param {OrderQuery} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrders(query: OrderQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrders(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrdersByAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findOrdersByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of top level orders, ie. those not sent by an SOR or Algo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findParentOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findParentOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findParentOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPositionsByAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPositionsByAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findPositionsByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findStrategy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findStrategy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.findStrategy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountKey(accountId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getAccountKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCounterparties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCounterparties(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getCounterparties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(entityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFills(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExecutionReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFills(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getFills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(orderId: string, target?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMessages200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessages(orderId, target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of an existing order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionForAccountAndAsset(accountId: number, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionForAccountAndAsset(accountId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getPositionForAccountAndAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositionsForAsset(assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositionsForAsset(assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getPositionsForAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrice(asset: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrice(asset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenues(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Venue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVenues(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.getVenues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [venue] Venue
         * @param {string} [base] Base Asset
         * @param {string} [quote] QuoteAsset
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instruments(venue?: string, base?: string, quote?: string, symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instruments(venue, base, quote, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.instruments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountKeyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listAccountKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listAllAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllEntities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllEntities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listAllEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntityAccounts(entityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntityAccounts(entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listEntityAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubAccounts(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubAccounts(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listSubAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRoles(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0UserMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [q] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(q?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0UserPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(q, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logon(accountId: number, keyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logon(accountId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.logon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newAccountOrder(accountId: number, newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newAccountOrder(accountId, newOrderSingle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.newAccountOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseStrategy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseStrategy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.pauseStrategy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshPositions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshPositions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.refreshPositions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeStrategy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeStrategy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.resumeStrategy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Slice an existing order into a new order
         * @param {Order} orderId 
         * @param {number} orderQty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slice(orderId: Order, orderQty: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slice(orderId, orderQty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.slice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.streamEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async time(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.time(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.time']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.updateAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {Auth0UserMetadataPatchDto} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoles(userId: string, roles: Auth0UserMetadataPatchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoles(userId, roles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtexApi.updateUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtexApi - factory interface
 * @export
 */
export const VirtexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtexApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a pending Manual order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrder(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a fill to an existing order
         * @param {string} orderId 
         * @param {{ [key: string]: number; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFill(orderId: string, requestBody: { [key: string]: number; }, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addFill(orderId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {ExecutionReport} executionReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFill1(orderId: string, executionReport: ExecutionReport, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addFill1(orderId, executionReport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} account 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole(userId: string, account: number, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Auth0UserDto> {
            return localVarFp.addUserRole(userId, account, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel an existing order by ClOrdId
         * @param {number} accountId 
         * @param {string} clOrdId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelByClOrdId(accountId: number, clOrdId: string, force?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelByClOrdId(accountId, clOrdId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel an existing order
         * @param {string} orderId 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, force?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelOrder(orderId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountDto} accountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountDto: AccountDto, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.createAccount(accountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountKeyDto} accountKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountKey(accountId: number, accountKeyDto: AccountKeyDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountKeyDto> {
            return localVarFp.createAccountKey(accountId, accountKeyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EntityDto} entityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(entityDto: EntityDto, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.createEntity(entityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Order
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig): AxiosPromise<OrderDto> {
            return localVarFp.createOrder(newOrderSingle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PositionDto} positionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPositionReport(positionDto: PositionDto, options?: RawAxiosRequestConfig): AxiosPromise<PositionReport> {
            return localVarFp.createPositionReport(positionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Quote} quote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(quote: Quote, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createQuote(quote, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {AccountMessage} accountMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubAccount(accountId: number, accountMessage: AccountMessage, options?: RawAxiosRequestConfig): AxiosPromise<AccountDto> {
            return localVarFp.createSubAccount(accountId, accountMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(options?: RawAxiosRequestConfig): AxiosPromise<TokenDto> {
            return localVarFp.createToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteAccountKey(accountId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Deposit} deposit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(deposit: Deposit, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deposit(deposit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCached(options?: RawAxiosRequestConfig): AxiosPromise<Array<PositionDto>> {
            return localVarFp.findAllCached(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllExchanges(options?: RawAxiosRequestConfig): AxiosPromise<Array<EntityDto>> {
            return localVarFp.findAllExchanges(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPositions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PositionDto>> {
            return localVarFp.findAllPositions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all child slices for an existing orer
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findChildren(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDto>> {
            return localVarFp.findChildren(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInstrument(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Instrument> {
            return localVarFp.findInstrument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOpenOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDto>> {
            return localVarFp.findOpenOrdersByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all visible orders
         * @param {OrderQuery} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrders(query: OrderQuery, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDto>> {
            return localVarFp.findOrders(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDto>> {
            return localVarFp.findOrdersByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of top level orders, ie. those not sent by an SOR or Algo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findParentOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDto>> {
            return localVarFp.findParentOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPositionsByAccount(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PositionDto>> {
            return localVarFp.findPositionsByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStrategy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StrategyState> {
            return localVarFp.findStrategy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountDto> {
            return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountKey> {
            return localVarFp.getAccountKey(accountId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterparties(options?: RawAxiosRequestConfig): AxiosPromise<Array<Ent>> {
            return localVarFp.getCounterparties(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entityId: number, options?: RawAxiosRequestConfig): AxiosPromise<EntityDto> {
            return localVarFp.getEntity(entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFills(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ExecutionReport>> {
            return localVarFp.getFills(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(orderId: string, target?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMessages200ResponseInner>> {
            return localVarFp.getMessages(orderId, target, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of an existing order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderDto> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionForAccountAndAsset(accountId: number, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<PositionDto> {
            return localVarFp.getPositionForAccountAndAsset(accountId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositionsForAsset(assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PositionDto>> {
            return localVarFp.getPositionsForAsset(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice(asset: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getPrice(asset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options?: RawAxiosRequestConfig): AxiosPromise<TokenDto> {
            return localVarFp.getToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.getTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Auth0UserDto> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenues(options?: RawAxiosRequestConfig): AxiosPromise<Array<Venue>> {
            return localVarFp.getVenues(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [venue] Venue
         * @param {string} [base] Base Asset
         * @param {string} [quote] QuoteAsset
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instruments(venue?: string, base?: string, quote?: string, symbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.instruments(venue, base, quote, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountKeyDto>> {
            return localVarFp.listAccountKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountDto>> {
            return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllAccounts(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listAllAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllEntities(options?: RawAxiosRequestConfig): AxiosPromise<Array<EntityDto>> {
            return localVarFp.listAllEntities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities(options?: RawAxiosRequestConfig): AxiosPromise<Array<EntityDto>> {
            return localVarFp.listEntities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntityAccounts(entityId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Account>> {
            return localVarFp.listEntityAccounts(entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubAccounts(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountDto>> {
            return localVarFp.listSubAccounts(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Auth0UserMetadata> {
            return localVarFp.listUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(q?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Auth0UserPage> {
            return localVarFp.listUsers(q, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logon(accountId: number, keyId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logon(accountId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {NewOrderSingle} newOrderSingle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newAccountOrder(accountId: number, newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig): AxiosPromise<OrderDto> {
            return localVarFp.newAccountOrder(accountId, newOrderSingle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseStrategy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pauseStrategy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPositions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.refreshPositions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeStrategy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resumeStrategy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Slice an existing order into a new order
         * @param {Order} orderId 
         * @param {number} orderQty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slice(orderId: Order, orderQty: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.slice(orderId, orderQty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.streamEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        time(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.time(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccounts(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {Auth0UserMetadataPatchDto} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(userId: string, roles: Auth0UserMetadataPatchDto, options?: RawAxiosRequestConfig): AxiosPromise<Auth0UserDto> {
            return localVarFp.updateUserRoles(userId, roles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtexApi - object-oriented interface
 * @export
 * @class VirtexApi
 * @extends {BaseAPI}
 */
export class VirtexApi extends BaseAPI {
    /**
     * 
     * @summary Accept a pending Manual order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public acceptOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).acceptOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a fill to an existing order
     * @param {string} orderId 
     * @param {{ [key: string]: number; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public addFill(orderId: string, requestBody: { [key: string]: number; }, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).addFill(orderId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {ExecutionReport} executionReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public addFill1(orderId: string, executionReport: ExecutionReport, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).addFill1(orderId, executionReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} account 
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public addUserRole(userId: string, account: number, role: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).addUserRole(userId, account, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel an existing order by ClOrdId
     * @param {number} accountId 
     * @param {string} clOrdId 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public cancelByClOrdId(accountId: number, clOrdId: string, force?: boolean, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).cancelByClOrdId(accountId, clOrdId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel an existing order
     * @param {string} orderId 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public cancelOrder(orderId: string, force?: boolean, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).cancelOrder(orderId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountDto} accountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createAccount(accountDto: AccountDto, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createAccount(accountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {AccountKeyDto} accountKeyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createAccountKey(accountId: number, accountKeyDto: AccountKeyDto, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createAccountKey(accountId, accountKeyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EntityDto} entityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createEntity(entityDto: EntityDto, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createEntity(entityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Order
     * @param {NewOrderSingle} newOrderSingle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createOrder(newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createOrder(newOrderSingle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PositionDto} positionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createPositionReport(positionDto: PositionDto, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createPositionReport(positionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Quote} quote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createQuote(quote: Quote, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createQuote(quote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {AccountMessage} accountMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createSubAccount(accountId: number, accountMessage: AccountMessage, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createSubAccount(accountId, accountMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public createToken(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).createToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {number} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public deleteAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).deleteAccountKey(accountId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Deposit} deposit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public deposit(deposit: Deposit, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).deposit(deposit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findAllCached(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findAllCached(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findAllExchanges(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findAllExchanges(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findAllPositions(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findAllPositions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all child slices for an existing orer
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findChildren(orderId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findChildren(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findInstrument(id: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findInstrument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findOpenOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findOpenOrdersByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all visible orders
     * @param {OrderQuery} query 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findOrders(query: OrderQuery, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findOrders(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findOrdersByAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findOrdersByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of top level orders, ie. those not sent by an SOR or Algo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findParentOrders(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findParentOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findPositionsByAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findPositionsByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public findStrategy(id: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).findStrategy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {number} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getAccountKey(accountId: number, keyId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getAccountKey(accountId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getCounterparties(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getCounterparties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getEntity(entityId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getEntity(entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getFills(orderId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getFills(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} [target] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getMessages(orderId: string, target?: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getMessages(orderId, target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of an existing order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getPositionForAccountAndAsset(accountId: number, assetId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getPositionForAccountAndAsset(accountId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getPositionsForAsset(assetId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getPositionsForAsset(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} asset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getPrice(asset: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getPrice(asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getToken(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getTransactions(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public getVenues(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).getVenues(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [venue] Venue
     * @param {string} [base] Base Asset
     * @param {string} [quote] QuoteAsset
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public instruments(venue?: string, base?: string, quote?: string, symbol?: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).instruments(venue, base, quote, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listAccountKeys(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listAccountKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listAccounts(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listAllAccounts(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listAllAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listAllEntities(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listAllEntities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listEntities(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listEntities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listEntityAccounts(entityId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listEntityAccounts(entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listSubAccounts(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listSubAccounts(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listUserRoles(userId: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public listUsers(q?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).listUsers(q, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {number} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public logon(accountId: number, keyId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).logon(accountId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {NewOrderSingle} newOrderSingle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public newAccountOrder(accountId: number, newOrderSingle: NewOrderSingle, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).newAccountOrder(accountId, newOrderSingle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public pauseStrategy(id: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).pauseStrategy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public refreshPositions(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).refreshPositions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public resumeStrategy(id: string, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).resumeStrategy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Slice an existing order into a new order
     * @param {Order} orderId 
     * @param {number} orderQty 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public slice(orderId: Order, orderQty: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).slice(orderId, orderQty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public streamEvents(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).streamEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public time(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).time(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public updateAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).updateAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public updateAccounts(options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).updateAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {Auth0UserMetadataPatchDto} roles 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtexApi
     */
    public updateUserRoles(userId: string, roles: Auth0UserMetadataPatchDto, options?: RawAxiosRequestConfig) {
        return VirtexApiFp(this.configuration).updateUserRoles(userId, roles, options).then((request) => request(this.axios, this.basePath));
    }
}



